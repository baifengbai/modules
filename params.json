{
  "name": "Modules in R",
  "tagline": "Manage dependencies between your R files / functions / modules",
  "body": "[![Build Status](https://travis-ci.org/wahani/modules.png?branch=master)](https://travis-ci.org/wahani/modules)\r\n[![codecov.io](https://codecov.io/github/wahani/modules/coverage.svg?branch=master)](https://codecov.io/github/wahani/modules?branch=master)\r\n[![CRAN](http://www.r-pkg.org/badges/version/modules)](https://cran.r-project.org/package=modules)\r\n![Downloads](http://cranlogs.r-pkg.org/badges/modules)\r\n# Modules in R\r\n\r\nProvides modules as an organizational unit for source code. Modules\r\nenforce to be more rigorous when defining dependencies and have\r\na local search path. They can be used as a sub unit within packages\r\nor in scripts.\r\n\r\n## Installation\r\n\r\nFrom CRAN:\r\n\r\n```r\r\ninstall.packages(\"modules\")\r\n```\r\n\r\nFrom GitHub:\r\n\r\n\r\n```r\r\ndevtools::install_github(\"wahani/modules\")\r\n```\r\n\r\n# Introduction\r\n\r\nThe key idea of this package is to provide a unit of source code which has it's\r\nown scope. The main and most reliable infrastructure for such organizational\r\nunits in the R ecosystem is a package. Modules can be used as stand alone,\r\nad-hoc substitutes for a package or as a sub-unit within a package.\r\n\r\nWhen modules are defined inside of packages they act as bags of functions (like\r\nobjects as in object-oriented-programming). Outside of packages modules define\r\nentities which only know of the base environment, i.e. within a module the base\r\nenvironment is the only *package* on the *search path*. Also they are always\r\nrepresented as a list inside R.\r\n\r\nSome core features:\r\n\r\n\r\n```r\r\nlibrary(\"modules\")\r\nm <- module({\r\n  boringFunction <- function() \"boring output\"\r\n})\r\nm$boringFunction()\r\n```\r\n\r\n```\r\n## [1] \"boring output\"\r\n```\r\n\r\nSince they are isolated from the `.GlobalEnv` the following object `x` can not\r\nbe found:\r\n\r\n\r\n```r\r\nx <- \"hey\"\r\nm <- module({\r\n  someFunction <- function() x\r\n})\r\nm$someFunction()\r\n```\r\n\r\n```\r\n## Error in m$someFunction(): object 'x' not found\r\n```\r\n\r\n\r\n## Imports\r\n\r\nIf you rely on exported objects of a package you can refer to them explicitly\r\nusing `::`:\r\n\r\n\r\n```r\r\nm <- module({\r\n  functionWithDep <- function(x) stats::median(x)\r\n})\r\nm$functionWithDep(1:10)\r\n```\r\n\r\n```\r\n## [1] 5.5\r\n```\r\n\r\nOr you can use `import` for *attaching* single objects or packages and `use` for\r\n*attaching* or loading a module:\r\n\r\n\r\n```r\r\nm <- module({\r\n \r\n  import(\"stats\", \"median\") # make median from package stats available\r\n  \r\n  functionWithDep <- function(x) median(x)\r\n\r\n})\r\nm$functionWithDep(1:10)\r\n```\r\n\r\n```\r\n## [1] 5.5\r\n```\r\n\r\n\r\n```r\r\nm <- module({\r\n  \r\n  import(\"stats\")\r\n  \r\n  functionWithDep <- function(x) median(x)\r\n\r\n})\r\nm$functionWithDep(1:10)\r\n```\r\n\r\n```\r\n## [1] 5.5\r\n```\r\n\r\n## Exports\r\n\r\nIt may also be of interest to control which objects are visible for the client.\r\nYou can do that with the `export` function. Note that export accepts regular\r\nexpressions which are indicated by a leading '^'.\r\n\r\n\r\n```r\r\nm <- module({\r\n  \r\n  export(\"fun\")\r\n\r\n  fun <- identity # public\r\n  privateFunction <- identity\r\n  \r\n  # .named are always private\r\n  .privateFunction <- identity\r\n  \r\n})\r\n\r\nnames(m)\r\n```\r\n\r\n```\r\n## [1] \"fun\"\r\n```\r\n\r\n## Example: Modules as Parallel Process\r\n\r\nOne example where you may want to have more control of the enclosing environment \r\nof a function is when you parallelize your code. First consider the case when a \r\n*naive* implementation fails.\r\n\r\n\r\n```r\r\nlibrary(\"parallel\")\r\ndependency <- identity\r\nfun <- function(x) dependency(x) \r\n\r\ncl <- makeCluster(2)\r\nclusterMap(cl, fun, 1:2)\r\n```\r\n\r\n```\r\n## Error in checkForRemoteErrors(val): 2 nodes produced errors; first error: could not find function \"dependency\"\r\n```\r\n\r\n```r\r\nstopCluster(cl)\r\n```\r\n\r\nTo make the function `fun` self contained we can define it in a module. \r\n\r\n\r\n```r\r\nm <- module({\r\n  dependency <- identity\r\n  fun <- function(x) dependency(x) \r\n})\r\n\r\ncl <- makeCluster(2)\r\nclusterMap(cl, m$fun, 1:2)\r\n```\r\n\r\n```\r\n## [[1]]\r\n## [1] 1\r\n## \r\n## [[2]]\r\n## [1] 2\r\n```\r\n\r\n```r\r\nstopCluster(cl)\r\n```\r\n\r\nNote that the parallel computing facilities in `R` always provide a way to\r\nhandle such situations. Here it is just a matter of organization if you believe\r\nthe function itself should handle its dependencies or the parallel interface.\r\n\r\n\r\n# Related Projects\r\n\r\nThere exist several projects with similar goals. First of all, the package\r\n[klmr/modules](https://github.com/klmr/modules) aims at providing a unit similar\r\nto what [Python](https://www.python.org/)-modules are. This project is obviously\r\ninteresting for you when you have prior knowledge in Python. In contrast to\r\n`klmr/modules` modules defined here do not aim for a full replacement of\r\nR-packages -- rather they provide a sub-unit within R's package\r\necosystem. Otherwise there is considerable overlap of features between the two\r\npackages.\r\n\r\nSecond you may be interested in\r\n[import](https://cran.r-project.org/package=import) which provides convenient\r\nsyntax for stating dependencies in script files. This is something which is also\r\ncovered here, although, when you are only interested in a replacement for\r\n`library` the package `import` is more focused. \r\n\r\n`modules` in this package can act as objects as in object-orientation. In \r\ncontrast to [R6](https://cran.r-project.org/package=R6) and reference classes\r\nimplemented in the methods package here these objects are immutable by default.\r\nFurthermore it is not being made easy to change state of a module; but it is not\r\ndifficult to do that if you really want to: see the section on coupling below.\r\nFurthermore inheritance is not a feature, instead you have various possibilities\r\nfor object composition.\r\n\r\nThe development of the `modules` package has been inspired by other languages:\r\n[F#](https://fsharpforfunandprofit.com/posts/organizing-functions/), \r\n[Erlang](http://learnyousomeerlang.com/modules) and \r\n[julia](http://docs.julialang.org/en/release-0.4/manual/modules/).\r\n\r\n\r\n# Scripts as modules\r\n\r\nYou can load scripts as modules when you refer to a file (or directory) in a\r\ncall to `use`. Inside such a script you can use `import` and `use` in the same\r\nway you typically use `library`. A major difference is, that library will not\r\nonly attach the stated package but also all packages in the depends field of\r\nthat package. This is something you have to do manually (explicitly) with\r\n`import`. Consider the following example where we create a module in a temporary\r\nfile with its dependencies.\r\n\r\n\r\n```r\r\ncode <- \"\r\nimport('stats', 'median')\r\nfunctionWithDep <- function(x) median(x)\r\n\"\r\n\r\nfileName <- tempfile(fileext = \".R\")\r\nwriteLines(code, fileName)\r\n```\r\n\r\nThen we can load such a module into this session by the following:\r\n\r\n\r\n```r\r\nm <- use(fileName)\r\nm$functionWithDep(1:2)\r\n```\r\n\r\n```\r\n## [1] 1.5\r\n```\r\n\r\n\r\n# Nested Modules\r\n\r\nYou can also write nested modules, which means you define modules inside\r\nmodules. In this case dependencies of the top level module are accessible to its\r\nchildren:\r\n\r\n\r\n```r\r\nm <- module({\r\n  \r\n  import(\"stats\", \"median\")\r\n  import(\"modules\", \"module\")\r\n  \r\n  anotherModule <- module({\r\n    fun <- function(x) median(x)\r\n  })\r\n  \r\n})\r\n\r\nm$anotherModule$fun(1:2)\r\n```\r\n\r\n```\r\n## [1] 1.5\r\n```\r\n\r\n\r\n# Documentation\r\n\r\nIf you want proper documentation for your functions or modules you really want a\r\npackage. However, there are some simple things you can do for ad-hoc\r\ndocumentation of modules which is to use comments:\r\n\r\n\r\n```r\r\nmodule({\r\n  fun <- function(x) {\r\n    ## A function for illustrating documentation\r\n    ## x (numeric)\r\n    x\r\n  }\r\n})\r\n```\r\n\r\n```\r\n## fun:\r\n## function(x)\r\n## ## A function for illustrating documentation\r\n## ## x (numeric)\r\n```\r\n\r\n\r\n# Modules in Packages\r\n\r\nYou can use modules inside packages in the same way as illustrated above. When a\r\nmodule is defined inside a R-package its search path connects to the packages\r\nnamespace. So it sees all objects within the package and has access to all its\r\ndependencies. You can always change this by specifying the argument `topEncl`\r\nwhen calling `module`. Do not use `import` inside this setting but instead rely\r\non the package to handle your dependencies. Attaching other modules using `use`\r\nand `expose` can make sense but is a matter of preference. You should definitely\r\nnot rely on modules in files and load them with `use`!\r\n\r\n\r\n# Modules with Object Orientation\r\n\r\n## S3\r\n\r\nS3 method dispatch can be problamatic because of the special search mechanism of\r\n`UseMethod`. What will work, however, is wrapping the generic function in a\r\nwrapper function.\r\n\r\n\r\n```r\r\nm <- module({\r\n  .generic <- function(x) UseMethod(\"generic\")\r\n  generic.numeric <- function(x) cat(\"method for x ~ numeric\")\r\n  generic <- function(x) .generic(x)\r\n})\r\nm$generic(1)\r\n```\r\n\r\n```\r\n## method for x ~ numeric\r\n```\r\n\r\n## S4\r\n\r\nBy default the *set* functions of the methods package have side effects in the\r\ntop level environment. So you would have to set the appropriate environment for\r\nthe argument 'where'. However if you really have the need for S4 generics,\r\nclasses and methods you should consider writing a package instead; or if you are\r\nalready in a package define them in the scope of the package.\r\n\r\n\r\n# Modules and Coupling\r\n\r\nBest is to only use `::` and `use` with `attach = FALSE` to be explicit with \r\nyour dependencies. However, there are some other options you have, which will\r\nresult in stronger forms of coupling between modules.\r\n\r\n## Modules to Model Mutable State\r\n\r\nThis is in itself abstract but in principle you can not only put functions in\r\nyour bag (module) but any R-object. This transforms into something which is\r\nprobably associated with object-orientation. You can like this or not, here I\r\nsimply use it to illustrate the strongest form of coupling between two modules I\r\ncan come up with. \r\n\r\nIn the following I define a module to encapsulate some value and have a *get*\r\nand *set* method for it:\r\n\r\n\r\n```r\r\nmutableModule <- module({\r\n  .num <- NULL\r\n  get <- function() .num\r\n  set <- function(val) .num <<- val\r\n})\r\nmutableModule$get()\r\n```\r\n\r\n```\r\n## NULL\r\n```\r\n\r\n```r\r\nmutableModule$set(2)\r\n```\r\n\r\n## Coupling Between Modules\r\n\r\nIn the next module we can use `mutableModule` and rebuild the interface to\r\n`.num`.\r\n\r\n\r\n```r\r\ncomplectModule <- module({\r\n  use(.GlobalEnv$mutableModule, attach = TRUE)\r\n  getNum <- function() get()\r\n  set(3)\r\n})\r\nmutableModule$get()\r\n```\r\n\r\n```\r\n## [1] 2\r\n```\r\n\r\n```r\r\ncomplectModule$getNum()\r\n```\r\n\r\n```\r\n## [1] 3\r\n```\r\n\r\nDepending on your expectations with respect to the above code it comes at a\r\nsurprise that we can get and set that value from an attached module; Furthermore\r\nit is not changed in `mutableModule`. This is because `use` will trigger a\r\nre-initialization of any module you plug in. You can override this behaviour:\r\n\r\n\r\n```r\r\ncomplectModule <- module({\r\n  use(.GlobalEnv$mutableModule, attach = TRUE, reInit = FALSE)\r\n  getNum <- function() get()\r\n  set(3)\r\n})\r\nmutableModule$get()\r\n```\r\n\r\n```\r\n## [1] 3\r\n```\r\n\r\n```r\r\ncomplectModule$getNum()\r\n```\r\n\r\n```\r\n## [1] 3\r\n```\r\n\r\nThis is not all we can do. Also we can use `expose`. This function will take\r\neverything in a module and expose it to the environment from which it is called.\r\n\r\n\r\n```r\r\ncomplectModule <- module({\r\n  expose(.GlobalEnv$mutableModule, reInit = TRUE)\r\n  set(4)\r\n})\r\nmutableModule$get()\r\n```\r\n\r\n```\r\n## [1] 3\r\n```\r\n\r\n```r\r\ncomplectModule$get()\r\n```\r\n\r\n```\r\n## [1] 4\r\n```\r\n\r\nAnd of course we can do this with `reInit = FALSE` should this be desirable. In\r\nthis case both modules are essentially a copy of a reference.\r\n\r\n\r\n```r\r\ncomplectModule <- module({\r\n  expose(.GlobalEnv$mutableModule, reInit = FALSE)\r\n  set(1)\r\n})\r\nmutableModule$get()\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n```r\r\ncomplectModule$get()\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}