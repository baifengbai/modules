[![Build Status](https://travis-ci.org/wahani/module.png?branch=master)](https://travis-ci.org/wahani/module)

# Modules in R
```{r, results='asis', echo=FALSE}
cat(gsub("\\n   ", "", packageDescription("module", fields = "Description")))
```

## Installation

From this repo:
```{r, eval=FALSE}
library(devtools)
install_github("wahani/aoos")
```

```{r, echo=FALSE}
# wahaniMiscs::getLocalPackageUpdates("module")
```

## Modules

```{r}
m <- module({
  boringFunction <- function() cat("boring output")
})

m$boringFunction()
str(m) # it's just a list
```

Modules have their own scope, and have no idea whats going on around them:

```{r error=TRUE}
hey <- "hey"
m <- module({
  isolatedFunction <- function() hey
})
m$isolatedFunction()
```

Unless you force them to rely on some unknown quantity outside their control:

```{r}
m <- module({
  isolatedFunction <- function() .GlobalEnv$hey
})
m$isolatedFunction()
```

You have to rely on exported things of packages at some point:

```{r}
m <- module({
  functionWithDep <- function(x) stats::median(x)
})
m$functionWithDep(1:10)
```

Or if you like to have more lines or state your dependencies on top:

```{r}
m <- module({
  import(stats, median)
  functionWithDep <- function(x) median(x)
})
m$functionWithDep(1:10)
```

You can also use other modules by makeing all their exported functions
available in your new module definition.

```{r}
m1 <- module({
  use(.GlobalEnv$m) # normally: pkgName::moduleName
  anotherFunction <- function(x) functionWithDep(x)
})
str(m1)
m1$anotherFunction(1:10)
```

Because this needs to fit into my normal workflow things like this are also possible:

```{r}
m <- module({
  use("package:methods")
  use("package:aoos")
  gen(x) %g% cat("default method")
  gen(x ~ numeric) %m% cat("method for x ~ numerc")
})
m$gen("Hej")
m$gen(1)
```

This gets messy if you rely on packages, like aoos, which depend on other
packages to be on the search path. In case of the methods package there is no
way around this because it is needed for everything related to S4s object
orientation. With well written packages this is no problem.

One example where you may want to have more control of the enclosing environment 
of a function is when you parallize your code:

```{r error=TRUE}
library(parallel)
dependsOn <- function(x) median(x)
fun <- function(x) dependsOn(x) 

cl <- makeCluster(2)
clusterMap(cl, fun, replicate(2, 1:10, simplify = FALSE))
stopCluster(cl)
```

There are of course other options to solve this, anyway, here we go:

```{r}
m <- module({
  import(stats, median)
  dependsOn <- function(x) median(x)
  fun <- function(x) dependsOn(x) 
})

cl <- makeCluster(2)
clusterMap(cl, m$fun, replicate(2, 1:10, simplify = FALSE))
stopCluster(cl)
```
